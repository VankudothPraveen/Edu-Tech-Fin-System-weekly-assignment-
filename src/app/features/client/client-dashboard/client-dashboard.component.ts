import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule } from '@angular/router';
import { AuthService } from '../../../auth/auth-service';
import { Client } from '../../../models/client';
import { Training, Milestone } from '../../../models/training';
import { PO } from '../../../models/po-model';
import { NotificationService } from '../../../shared/notification.service';

@Component({
    selector: 'app-client-dashboard',
    standalone: true,
    imports: [CommonModule, RouterModule],
    templateUrl: './client-dashboard.component.html',
    styleUrl: './client-dashboard.component.css'
})
export class ClientDashboardComponent implements OnInit {
    client: Client | null = null;
    ongoingTrainings: Training[] = [];
    completedTrainings: Training[] = [];
    clientPO: PO | null = null;

    constructor(
        private authService: AuthService,
        private notificationService: NotificationService
    ) { }

    ngOnInit(): void {
        this.loadClientData();
        this.loadClientPO();
    }

    loadClientData(): void {
        const userId = this.authService.getUserId();
        if (!userId) return;

        const clients = JSON.parse(localStorage.getItem('clients') || '[]');
        this.client = clients.find((c: Client) => c.userId === userId);

        if (this.client) {
            const trainings = JSON.parse(localStorage.getItem('trainings') || '[]');
            const myTrainings = trainings.filter((t: Training) => t.clientId === this.client!.id);

            this.ongoingTrainings = myTrainings.filter((t: Training) => t.status === 'ONGOING');
            this.completedTrainings = myTrainings.filter((t: Training) => t.status === 'COMPLETED');
        }
    }

    loadClientPO(): void {
        if (!this.client) return;

        const pos = JSON.parse(localStorage.getItem('pos') || '[]');
        this.clientPO = pos.find((po: PO) => po.clientId === this.client!.id && po.type === 'CLIENT_PO');
    }

    generatePO(): void {
        if (!this.client || this.client.status !== 'APPROVED') {
            alert('⚠️ Cannot Generate PO\n\nOnly approved clients can generate Purchase Orders.\nPlease wait for admin approval.');
            return;
        }

        if (this.clientPO) {
            alert('⚠️ PO Already Generated!\n\nYou have already generated a Purchase Order.\nPO Number: ' + this.clientPO.poNumber);
            return;
        }

        const poNumber = `PO-CLIENT-${Date.now()}`;
        const amount = this.client.budget || 0;
        
        const newPO: PO = {
            id: `po_${Date.now()}`,
            poNumber: poNumber,
            type: 'CLIENT_PO',
            clientId: this.client.id,
            amount: amount,
            description: `Purchase Order for ${this.client.technology} training - ${this.client.duration}`,
            status: 'GENERATED',
            generatedAt: new Date().toISOString()
        };

        const pos = JSON.parse(localStorage.getItem('pos') || '[]');
        pos.push(newPO);
        localStorage.setItem('pos', JSON.stringify(pos));

        // Notify admin about new PO
        this.authService.createNotification({
            recipientId: 'admin-001',
            recipientRole: 'admin',
            message: `New Purchase Order generated by ${this.client.name}. PO#: ${poNumber}, Amount: $${amount.toLocaleString()}`,
            type: 'info',
            timestamp: new Date(),
            read: false
        });

        this.clientPO = newPO;
        
        // Show success message
        alert(`✅ Purchase Order Generated Successfully!\n\n` +
              `PO Number: ${poNumber}\n` +
              `Amount: $${amount.toLocaleString()}\n` +
              `Technology: ${this.client.technology}\n` +
              `Duration: ${this.client.duration}\n\n` +
              `Your PO has been sent to the admin for processing.`);
        
        console.log('✅ PO Generated:', newPO);
        this.loadClientPO();
    }
    
    verifyTrainingCompletion(training: Training): void {
        if (training.status !== 'COMPLETED') {
            alert('⚠️ Training Not Completed\n\nThis training is still ongoing. Please wait for the trainer to mark it as completed.');
            return;
        }

        const trainings = JSON.parse(localStorage.getItem('trainings') || '[]');
        const trainingIndex = trainings.findIndex((t: Training) => t.id === training.id);
        
        if (trainingIndex === -1) return;

        // Mark as verified by client
        trainings[trainingIndex].verifiedByClient = true;
        trainings[trainingIndex].verifiedAt = new Date().toISOString();
        localStorage.setItem('trainings', JSON.stringify(trainings));

        // Notify trainer
        this.authService.createNotification({
            recipientId: training.trainerId,
            recipientRole: 'trainer',
            message: `Training completion verified by ${this.client?.name}. You can now generate an invoice.`,
            type: 'success',
            timestamp: new Date(),
            read: false
        });

        alert(`✅ Training Verified!\n\nYou have successfully verified the completion of this training.\nThe trainer can now generate an invoice.`);
        this.loadClientData();
    }

    getTrainerName(trainerId: string): string {
        const trainers = JSON.parse(localStorage.getItem('trainers') || '[]');
        const trainer = trainers.find((t: any) => t.id === trainerId);
        return trainer ? trainer.name : 'Unknown Trainer';
    }

    markMilestoneComplete(training: Training, milestone: Milestone): void {
        if (milestone.status === 'COMPLETED') {
            alert('⚠️ Milestone Already Completed\n\nThis milestone has already been marked as completed.');
            return;
        }

        const dueDate = milestone.dueDate ? new Date(milestone.dueDate).toLocaleDateString() : 'N/A';
        const confirmMsg = `Are you sure you want to mark this milestone as completed?\n\n` +
                          `Module: ${milestone.title}\n` +
                          `Month: ${milestone.month}\n` +
                          `Due Date: ${dueDate}`;
        
        if (!confirm(confirmMsg)) return;

        const trainings = JSON.parse(localStorage.getItem('trainings') || '[]');
        const trainingIndex = trainings.findIndex((t: Training) => t.id === training.id);
        
        if (trainingIndex === -1) return;

        // Find and update the milestone
        const milestoneIndex = trainings[trainingIndex].milestones?.findIndex((m: Milestone) => m.id === milestone.id);
        
        if (milestoneIndex !== undefined && milestoneIndex !== -1) {
            trainings[trainingIndex].milestones[milestoneIndex].status = 'IN_PROGRESS';
            trainings[trainingIndex].milestones[milestoneIndex].completedAt = new Date().toISOString();
            trainings[trainingIndex].milestones[milestoneIndex].completedBy = 'client';

            // Update progress tracking
            const completedCount = trainings[trainingIndex].milestones.filter((m: Milestone) => m.status === 'IN_PROGRESS' || m.status === 'COMPLETED').length;
            trainings[trainingIndex].completedMilestones = completedCount;
            trainings[trainingIndex].progressPercentage = Math.round((completedCount / trainings[trainingIndex].totalMilestones) * 100);

            localStorage.setItem('trainings', JSON.stringify(trainings));

            // Notify trainer about milestone completion
            this.authService.createNotification({
                recipientId: training.trainerId,
                recipientRole: 'trainer',
                message: `${this.client?.name} completed milestone: ${milestone.title}. Please verify and mark as complete.`,
                type: 'info',
                timestamp: new Date(),
                read: false
            });

            // Notify admin
            this.authService.createNotification({
                recipientId: 'admin-001',
                recipientRole: 'admin',
                message: `Milestone completed: ${this.client?.name} - ${milestone.title} (${training.technology})`,
                type: 'info',
                timestamp: new Date(),
                read: false
            });

            alert(`✅ Milestone Marked Complete!\n\n${milestone.title}\n\nProgress: ${trainings[trainingIndex].progressPercentage}%\n\nWaiting for trainer verification...`);
            this.loadClientData();
        }
    }

    getMilestoneStatusClass(status: string): string {
        switch(status) {
            case 'COMPLETED': return 'badge-completed';
            case 'IN_PROGRESS': return 'badge-ongoing';
            case 'PENDING': return 'badge-requested';
            default: return 'badge-requested';
        }
    }

    getMilestoneStatusText(status: string): string {
        switch(status) {
            case 'COMPLETED': return 'Verified';
            case 'IN_PROGRESS': return 'Awaiting Verification';
            case 'PENDING': return 'Pending';
            default: return status;
        }
    }

    canMarkMilestoneComplete(milestone: Milestone): boolean {
        return milestone.status === 'PENDING';
    }

    logout(): void {
        this.authService.logout();
    }
}
